<!-- 챕터 7: 트랜잭션 보내기
    훌륭하군! 이제 우리의 UI는 사용자의 메타마스크 계정을 감지하고, 자동으로 좀비 군대를 홈페이지에 표현할 것이네.
    이제 send 함수를 이용해 스마트 컨트랙트의 데이터를 변경하는 방법을 살펴보도록 하지.
    이 함수에는 call 함수와는 꽤 다른 부분이 있네: (call - pure, view 함수를 위한 함수. send - pure, view를 제외한 모든 함수를 위한 함수)

    1. 트랜잭션을 전송(send)하려면 함수를 호출한 사람의 from 주소가 필요하네(솔리디티 코드에서는 msg.sender가 될 것이네). 
    이는 우리 DApp의 사용자가 되어야 할 것이니, 메타마스크가 나타나 그들에게 서명을 하도록 할걸세.
    2. 트랜잭션 전송(send)은 가스를 소모하네.
    3. 사용자가 트랜잭션 전송을 하고 난 후 실제로 블록체인에 적용될 때까지는 상당한 지연이 발생할 것이네. 
    트랜잭션이 블록에 포함될 때까지 기다려야 하는데, 이더리움의 평균 블록 시간이 15초이기 때문이지. 
    
    만약 이더리움에 보류 중인 거래가 많거나 사용자가 가스 가격을 지나치게 낮게 보낼 경우, 우리 트랜잭션이 블록에 포함되길 기다려야 하고, 이는 몇 분씩 걸릴 수 있네.
    그러니 이 코드의 비동기적 특성을 다루기 위한 로직이 필요하게 될 걸세.

    _좀비 만들기
    이제 사용자가 호출할 우리 컨트랙트 내의 첫번째 함수를 예제로 살펴보겠네: createRandomZombie.
    여기서 우리 컨트랙트의 솔리디티 코드를 다시 확인하겠네:
    ```
    function createRandomZombie(string _name) public {
      require(ownerZombieCount[msg.sender] == 0);
      uint randDna = _generateRandomDna(_name);
      randDna = randDna - randDna % 100;
      _createZombie(_name, randDna);
    }
    ```
    다음은 메타마스크를 사용해 Web3.js에서 위 함수를 호출하는 방법의 예제일세:
    ```
    function createRandomZombie(name) {
      // 시간이 꽤 걸릴 수 있으니, 트랜잭션이 보내졌다는 것을
      // 유저가 알 수 있도록 UI를 업데이트해야 함
      $("#txStatus").text("Creating new zombie on the blockchain. This may take a while...");
      // 우리 컨트랙트에 전송하기:
      return CryptoZombies.methods.createRandomZombie(name)
      .send({ from: userAccount })
      .on("receipt", function(receipt) {
        $("#txStatus").text("Successfully created " + name + "!");
        // 블록체인에 트랜잭션이 반영되었으며, UI를 다시 그려야 함
        getZombiesByOwner(userAccount).then(displayZombies);
      })
      .on("error", function(error) {
        // 사용자들에게 트랜잭션이 실패했음을 알려주기 위한 처리
        $("#txStatus").text(error);
      });
    }
    ```
    위 함수는 우리의 Web3 프로바이더에게 트랜잭션을 전송(send)하고, 몇 가지 이벤트 리스너들을 연결하네:
    ? receipt는 트랜잭션이 이더리움의 블록에 포함될 때, 즉 좀비가 생성되고 우리의 컨트랙트에 저장되었을 때 발생하게 되네.
    ? error는 트랜잭션이 블럭에 포함되지 못했을 때, 예를 들어 사용자가 충분한 가스를 전송하지 않았을 때 발생하게 되네. 
      우리는 우리의 UI를 통해 사용자에게 트랜잭션이 전송되지 않았음을 알리고, 다시 시도할 수 있도록 할 것이네.
    
    |참고: 자네가 send를 호출할 때 gas와 gasPrice를 선택적으로 지정할 수 있네. .send({ from: userAccount, gas: 3000000 })와 같이 말이야. 
          만약 지정하지 않는다면, 메타마스크는 사용자가 이 값들을 선택할 수 있도록 할 걸세.

    _직접 해보기
    ID가 txStatus인 div를 추가해 놓았네. 우린 이 div를 사용해 우리 트랜잭션의 상태를 사용자에게 메시지로 알릴 수 있네.

    1. displayZombies 아래에 위의 createRandomZombie를 복사/붙여넣기 하게.
    2. feedOnKitty 라는 또 다른 함수를 구현해보겠네.
    feedOnKitty를 호출하는 로직은 거의 동일하네 - 함수를 호출하는 트랜잭션을 보내고, 트랜잭션이 성공하면 새로운 좀비가 생성될 것이네. 그러니 성공 후에는 UI를 다시 그려야 할 것이네.
    createRandomZombie를 그것 바로 아래에 복사하고, 다음과 같이 변경하게:
      a. 2개의 인자 zombieId와 kittyId를 받는 두 번째 함수 feedOnKitty를 호출하게.
      b. #txStatus 텍스트를 다음과 같이 업데이트하게: "Eating a kitty. This may take a while..."
      c. 우리 컨트랙트의 feedOnKitty를 호출하게 하고, 같은 2개의 인자를 전달하게.
      d. #txStatus에 성공 메세지로 "Ate a kitty and spawned a new Zombie!"를 쓰게.

-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CryptoZombies front-end</title>
    <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script language="javascript" type="text/javascript" src="web3.min.js"></script>
    <script language="javascript" type="text/javascript" src="cryptozombies_abi.js"></script>
  </head>
  <body>
    <div id="txStatus"></div>
    <div id="zombies"></div>

    <script>
      var cryptoZombies;
      var userAccount;

      function startApp() {
        var cryptoZombiesAddress = "YOUR_CONTRACT_ADDRESS";
        cryptoZombies = new web3js.eth.Contract(cryptoZombiesABI, cryptoZombiesAddress);

        var accountInterval = setInterval(function() {
          // 계정이 바뀌었는지 확인
          if (web3.eth.accounts[0] !== userAccount) {
            userAccount = web3.eth.accounts[0];
            // 새 계정에 대한 UI로 업데이트하기 위한 함수 호출
            getZombiesByOwner(userAccount)
            .then(displayZombies);
          }
        }, 100);
      }

      function displayZombies(ids){
        $("#zombies").empty();
        for(id of ids){
          getZombieDetails(id)
          .then(function(zombie) {
            $("#zombies").append(
              `<div class="zombie">
                <ul>
                  <li>Name: ${zombie.name}</li>
                  <li>DNA: ${zombie.dna}</li>
                  <li>Level: ${zombie.level}</li>
                  <li>Wins: ${zombie.winCount}</li>
                  <li>Losses: ${zombie.lossCount}</li>
                  <li>Ready Time: ${zombie.readyTime}</li>
                </ul>
              </div>`
            );
          });
        }
      }
      // Start here
      function createRandomZombie(name) {
        // 시간이 꽤 걸릴 수 있으니, 트랜잭션이 보내졌다는 것을
        // 유저가 알 수 있도록 UI를 업데이트해야 함
        $("#txStatus").text("Creating new zombie on the blockchain. This may take a while...");
        // 우리 컨트랙트에 전송하기:
        return CryptoZombies.methods.createRandomZombie(name)
        .send({ from: userAccount })
        .on("receipt", function(receipt) {
          $("#txStatus").text("Successfully created " + name + "!");
          // 블록체인에 트랜잭션이 반영되었으며, UI를 다시 그려야 함
          getZombiesByOwner(userAccount).then(displayZombies);
        })
        .on("error", function(error) {
          // 사용자들에게 트랜잭션이 실패했음을 알려주기 위한 처리
          $("#txStatus").text(error);
        });
      }

      function feedOnKitty(zombieId, kittyId) {
        $("#txStatus").text("Eating a kitty. This may take a while...");
        return CryptoZombies.methods.feedOnKitty(zombieId, kittyId)
        // Web3 프로바이더에게 트랜잭션을 전송(send)
        .send({ from: userAccount })
        .on("receipt", function(receipt) {
          $("#txStatus").text("Ate a kitty and spawned a new Zombie!");
          getZombiesByOwner(userAccount).then(displayZombies);
        })
        .on("error", function(error) {
          $("#txStatus").text(error);
        })
      }

      function getZombieDetails(id) {
        return cryptoZombies.methods.zombies(id).call()
      }

      function zombieToOwner(id) {
        return cryptoZombies.methods.zombieToOwner(id).call()
      }

      function getZombiesByOwner(owner) {
        return cryptoZombies.methods.getZombiesByOwner(owner).call()
      }

      window.addEventListener('load', function() {

        // Web3가 브라우저에 주입되었는지 확인(Mist/MetaMask)
        if (typeof web3 !== 'undefined') {
          // Mist/MetaMask의 프로바이더 사용
          web3js = new Web3(web3.currentProvider);
        } else {
          // 사용자가 Metamask를 설치하지 않은 경우에 대해 처리
          // 사용자들에게 Metamask를 설치하라는 등의 메세지를 보여줄 것
        }

        // 이제 자네 앱을 시작하고 web3에 자유롭게 접근할 수 있네:
        startApp()

      })
    </script>
  </body>
</html>


